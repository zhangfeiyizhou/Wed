# 一：防抖和节流
           节流一般用于input输入框事件（oninput）
           防抖用于鼠标滚动事件(scroll：拖动滚动条时触发)
     

# 八，函数的防抖和节流
1. 为什么需要函数的防抖和节流
2. 因为高频事件，JS里面有一些事件触发的频率比较高，如：（scroll,oninput）

案例1：
<body> 
  请输入内容<input type="text" class="input">
</body>
</html>
</html>
<script>
let input = document.querySelector('.input')
function fn(){  //自定义函数
  console.log('输入时被触发')
}
input.oninput = fn //等于这个函数
如果输入'zhangfei'此时会被触发8次，而前7次，都是无效触发，产生资源的浪费
</script> 

# 函数的防抖：
     --当事件被触发一段时间后再执行事件，如果再这段时间内的事件又被触发，则重新计时

解决方案的思路：
     --在事件触发时开始计时，在规定的时间内，若再次触发事件，则讲上次计时清空，然后重新开始计时，保证只有在规定事件内没有再次触发事件之后，再去执行这个事件

防抖的所需条件：
     1.延时定时器
     2.封装函数实现函数的防抖

# 九.事件函数防抖的案例：
<body> 
  请输入内容<input type="text" class="input">
</body>
</html>
</html>
<script>
let input = document.querySelector('.input')
let time = null                   1.先声明一个定时器
function fn(){                    2.封装函数
  clearTimeout(time)              4.先消除延时定时器，保证在1s内不会被多次触发
  time = setTimeout(() => {       5.开启定时器
    console.log('输入时被触发')
  }, 1000);
}
input.oninput = fn                3.事件 = 这个封装函数（函数名=函数体）
</script> 
总结：
    1.事件触发的事件 = 封装函数内的内容
    2.函数内部给延时定时器，再规定的事件内（1s）不被多次触发
    3.每次延时定时器开启前，先消除延时定时器，（前面加 clearTimeout(time)）
    4.当输入时，只要打字的速度在1S内，就不会被多次触发，从而节约损耗性能

# 十.事件函数的节流：
        ---指定的时间间隔内，若事件被多次触发，只会执行一次

解决方案的思路：
     --在事件触发之后开始计时，在规定的时间内，若再次触发事件，则不对此事件做任何处理，保证在规定的时间内只执行一次事件


# 十.事件函数节流的案例：
<body> 
  请输入内容<input type="text" class="input">
</body>
</html>
</html>
<script>
let input = document.querySelector('.input')
function fn(){            2.事件函数
  let qishiTime = 0       3.先设置起始的时间撮为0
  return function(){      4.返回，函数
    let dangqTime = new Date().getTime()  5.当前的时间为：当前的时间撮
    if(dangqTime - qishiTime >= 1000){    6.如果当前的时间撮 - 起始的时间撮 >=1000毫秒
      console.log('输入即触发')            7.打印一次
      qishiTime = dangqTime               8.起始的时间撮 = 当前的时间撮
    }                       9.如果之前打字的时间和这一次打字时间不超过1毫秒，则不执行
  }
}
input.oninput = fn()    1.事件对象 = 事件函数
</script> 

# 一：闭包
1. 闭包是我们函数的一种高级使用方式
2. 内存划分：栈内存、堆内存、执行空间

# 二.函数的声明阶段：
1. 开辟一个存储空间
2. 把函数内的代码复制到这个空间（不解析变量）
3. 把存储空间的地址给函数名

# 三.函数的调用阶段：
1. 按照函数名的地址找到函数的存储空间
2. 形参赋值
3. 预解析
4. 在内存中开辟一个执行空间
5. 将函数存储空间的代码拿出来，在刚刚开辟的执行空间执行
6. 执行完毕后，内存中开辟的执行空间销毁

# 四.浏览器的垃圾回收机制
1. 标记:
       变量被引用时，给一个标记叫做进入环境，变量不被引用时，标记离开环境，浏览器将离开环境的变量回收

2. 计数：
       变量被引用时，身上的数字+1，释放时-1
                    身上的数字为0，浏览器将离开环境的变量回收

# 五.不被销毁的执行空间--的条件:
#                           1.函数内部返回一个引用数据类型
#                           2.在函数外部有变量来接受

# 六.闭包的形成条件：
1. 函数内部返回一个引用数据类型
2. 在函数外部有变量来接受
3. 能够读取其他函数内部的变量函数

# 七.闭包的作用，起到作用域，防止变量覆盖和冲突
<script>
!function(){
  var a = 1
  function fn(){
    console.log(a);//1
  }
  fn()
}()
!function(){
  var b = 2
  function fn(){
    console.log(b);//2
  }
  fn()
}()          //这里的变量a,b之间不会有冲突，只在作用域内有效，不会污染全局
</script>




